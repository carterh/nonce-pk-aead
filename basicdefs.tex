%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic Notions for Distribution-Matching Encryption}
\label{sec:basicdefs}

\paragraph{Distributions.} A probability distribution over a set $S$ is a map
$\dist\Colon S\rightarrow [0,1]$ that satisfies the requirement that 
$\sum_{s\in S} \dist(s) = 1$. The support of $\dist$ is the set  of 
all elements in $S$ with non-zero probability, i.e.,
$\supp(\dist) = \{s \in S \,|\, \dist(s) > 0\}$.  Sampling from a set $S$
according to a distribution $\dist$ using an appropriate number of fresh 
coins is denoted by $s \gets_{\dist} S$.
%Abusing notation slightly, we
%write $\supp(A)$ to denote the set of all values possibly ouput by a randomized algorithm
%$A$.   

\paragraph{DME schemes.}
Like a conventional symmetric encryption scheme,
a DME scheme $\DMEscheme =
(\enc,\dec)$ consists of two algorithms.  
%Key generation $\kg$ is randomized and outputs a secret key in $\bits^*$.  
Encryption $\enc$ takes input a key $\key \in \bits^*$ and a message $\msg \in\bits^*$, and
outputs a ciphertext $\ctxt \in \bits^*$ or a special error 
symbol~$\bot$. Decryption $\dec$ takes input a key and a ciphertext in
$\bits^*$ and outputs a message in $\mspace$ or $\bot$. 

We fix three distinguished sets $\kspace,\mspace,\cspace \subset \bits^*$ called
the key, message, and ciphertext space, respectively. We require that
$\enc(\key,\msg)$ outputs $\bot$ when $\key \notin \kspace$ or $\msg \notin
\mspace$. Similarly, $\dec(\key,\ctxt)$ must output $\bot$ when either the key
or ciphertext are not in the appropriate sets. Instead of having a key
generation algorithm, we assume keys are drawn from $\kspace$ according to
some distribution $\kdist$. For conventional secret keys, for example, one sets $\kspace =
\bits^k$ for some $k$ and $\kdist(\key) = 1/2^k$ for all $\key\in\kspace$.

%be a set called the key space and $\mspace
%\subset \bits^*$ be a set called the message space. These are defined as being
%the set of all keys and messages for which $\enc$ never outputs $\bot$. (When
%encryption is randomized, we assume that $\enc(K,M)$ outputs $\bot$ with either
%probability one or zero.)  Likewise we let $\cspace\subset \bits^*$ be the set
%of strings $C$ for which there exists a key and message for which the probability
%that $\dec(K,C)$ does not output $\bot$. 


%that 
%We assume that there exists a set $\mspace\subseteq\bits^*$, called the message
%space, such that $\enc(K,M)$ never outputs $\bot$ for any key $\key\in\kspace$ and any 
%$M \in \mspace$. We let
%$\cspace\subseteq\bits^*$ be the set of strings $C$ for which there exists a key and
%message for which the probability that $\enc(K,M)$ outputs $C$.

%Decryption $\dec$ takes input a key, a ciphertext in
%$\supp(\cdist)$ and outputs either a message in $\supp(\mdist)$ or $\bot$. 
We allow both encryption and decryption to be randomized or stateful.\tnote{Need
to discuss stateful in fuller detail , for example correctness is already a bit
messed up below}
%allowed to be stateful (we discuss stateful schemes in \fixme{??}).


%The message space is defined to be $\mspace = \supp(\mdist)$ and the ciphertext
%space is $\cspace = \supp(\cdist)$. Below when we say ``for all messages $M$''
%(resp.~``for all ciphertexts $C$'') the quantification is over an implicit
%message (resp.~ciphertext) space that will be clear from context.

%\paragraph{DME correctness.} 
We say that a DME scheme is
\emph{$\epsilon$-everywhere correct}  if for all messages $M$ and all keys $K$
\bnm
  \Prob{\dec(K,\enc(K,M) = M} \ge 1 - \epsilon 
\enm
where the probability is over the coins used by $\enc$. 
The notion of ``everywhere'' because we quantify over all messages in
the message space.  A scheme is \emph{perfectly everywhere correct} if it is
$\epsilon$-everywhere correct for $\epsilon=0$. 

\iffalse
We can also relax the above to take into account the message distribution. 
We say that a DME scheme is \emph{$\epsilon$-correct} 
if for all~$K$
\bnm
  \ProbExp{\dec(K,\enc(K,M) = M}{M \getm \mspace} \ge 1 - \epsilon 
\enm
where the probability is over the coins used to choose $M$ and within $\enc$.  
Thus in this relaxed formulation we do not quantify over all messages, but rather include in the
experiment sampling from $\mspace$. This means that, for example, we allow decryption 
to fail for messages that arise under $\mdist$ with probability less than
$\epsilon$.  A scheme is \emph{perfectly correct}  if it is $\epsilon$-correct for
$\epsilon=0$.

Deterministic DME schemes must be either perfectly everywhere correct or
perfectly correct.

Correctness mandates that the ciphertext space be large enough to
accomodate a sufficiently large portion of the message space. 
Put more precisely we have that at least
$|\cspace| \ge |S|$ where $S \subseteq \mspace$ is the smallest set 
for which  $1-\epsilon \le \sum_{s\in S} \mdist(s)$.
When we take into account security goals the requirements for the
ciphertext space will become more stringent.

\tnote{So I don't fully understand what you wrote below, so take that.}
\tsnote{I don't fully understand what's written above.  I assume the
  probability is over sampling of $M$ and the randomness used
  by~$\enc_K$?  I'm going to add some thoughts below this comment.}
Let $\cspace_{K,M} = \{C \in \cspace \;|\; \exists r \mbox{ such that
} C \gets \enc_K(M;r)\}$.  Let $G_{K,M} \subseteq \cspace_{K,M}$ be the
subset of ciphertexts that properly decrypt, that is $G_{K,M} = \{C
\in \cspace_{K,M} \;|\; \dec_K(C)=M\}$.  Let
$\delta_{K,M}=|G_{K,M}|/|\cspace_{K,M}|$ be the fraction of properly
decrypting ciphertexts of~$M$.  (In fact, $\delta_{K,M}$ is the
probability, over the randomness of encryption only, of correct
decryption of~$M$.) Then we demand that, for all $K$
\[
\mathbb{E}_{M}[\delta_{K,M}] =
\sum_{M}\frac{|G_{K,M}|}{|\cspace_{K,M}|}\mdist(M) \geq 1-\epsilon
\] 
this being the average probability (over messages) of correct decryption.
[[I think this just a way for me to better understand your definition of
$\epsilon$-correct above.]]
This is quite a flexible notion of correctness.  For example (as was
noted above), one can allow complete decryption failure on a fixed subset~$B
\subset \mspace$ such that $\mdist(B)\leq\epsilon$, and then require
perfect correctness on the rest of $\mspace$.  But there are certainly
other ways to meet this correctness condition; one just needs to
``spread'' the error across~$\mspace$ appropriately.

If the goal is to allow flexibility only on low-probability messages,
then we might consider the following alternative correctness
condition:  $\forall K$, $\forall M$ such that $\mdist(M) \geq \tau$, 
we require that $\Prob{\dec_K(\enc_K(M))=M}=1$, where the
probability is over the sampling of~$M$ and any coins of $\enc$.  Here
we don't care what happens on messages whose probability is less than
the threshold~$\tau$.

Another alternative is to let the probability of correctness by a
function of the probability of the message.  Thus, given a function
$f\colon (0,1] \to [0,1]$, for all $K$ we require that
$\Prob{\dec_K(\enc_K(M))=M} = f(\mdist(M))$.


\tsnote{end}
\fi

%\paragraph{Message and ciphertext distributions.} 
So far, nothing about DME is
different from conventional SE.  The deviation begins with  the fact that
DME schemes will be designed to with target a distribution over messages and
one over ciphertexts. The message distribution, denoted $\mdist$, specifies the
distribution from which the DME scheme designer expects plaintexts to be drawn.
This is inspired directly from honey encryption (HE), and in terms of security
the goal is that a ciphertext decrypted with the wrong key should result in a
plaintext distributed closely to $\mdist$. The ciphertext  distribution, 
denoted $\cdist$, is a target for what
emitted ciphertexts should ``look like''. This is inspired by stegonagraphy,
where $\cdist$ plays the role of the distribution of cover traffic or perhaps an 
innoucous-looking file. 

As an example, consider the simple hash based encryption scheme in which one
encrypts a message $M \in \mspace = \bits^\ell$ for some $\ell$ via 
$\enc(K,M) = (\salt , H(\salt \oplus K))$ for $\salt \getsr \bits^s$ and 
where $H\Colon\bits^*\rightarrow\bits^\ell$ is a cryptographic hash function.
Then, informally speaking, ciphertexts are distributed uniformly over 
$\bits^{s+\ell}$. Likewise, decrypting a fixed ciphertext $\salt,C$ using the
incorrect key will give back a plaintext distributed uniformly over
$\bits^{\ell}$. We will make these claims formal in \secref{sec:security}.

More challenging examples will be when we desire $\mdist$ and/or $\cdist$ to be
non-uniform or uniform over strange sets.
We will see some examples below of some existing encryption mechanisms that can
be cast as DME schemes.



\paragraph{Prior schemes falling under the DME framework.} The syntax and
semantics of the DME primitive, being equivalent to that of existing SE, means
that DME broadly encompasses a numer of previous schemes. As per the example
above, many conventional SE schemes can be viewed as DME schemes for which the
distributions $\mdist$ and $\cdist$ targeted are uniform over appropriate-length
bit strings. More involved examples include stegosystems~\cite{hopp}, honey encryption
(HE)~\cite{juels2014}, and format-transforming encryption (FTE)~\cite{ftepapers}: 

As first formalized by~\cite{hopper}, a stegosystem encodes a message using a
secret key in order to produce a covertext distributed indistinguishably from
some target distribution over ciphertexts (what they call the channel
distribution). We give more details about their formalization, and how it
compares to ours, in \apref{sec:stego-defs}. Suffice to say, we can think of any
stegosystem as a DME scheme with $\mdist$ uniform over bit strings, and where
$\cdist$ models the covertext distribution. As we will argue later in the paper,
a key benefit of viewing stegosystems as DME schemes is that we can provide
stegonographic security even when keys are low entropy (e.g., passwords). This
is not possible for existing schemes, and will allow us to build (among other
primitives) stegonagraphic password-based authenticated encryption (steg-PAKE). 

FTE~\cite{ftepapers} is a form of symmetric encryption in which ciphertexts must
abide by a prescribed format, which technically means they belong to a particular
set. Luchaup et al.~\cite{luchaup} generalize FTE to also consider only allowing
plaintexts from a certain set, making it a strict generalization of the earlier
primitive format-preserving encryption (FPE)~\cite{Bellare:2009}. We can view
FTE  as a DME scheme in which $\mdist$ and $\cdist$ are uniform over specified
sets $\mspace$ and $\cspace$.  For example, in their application in
anti-censorship, Dyer et al.~set $\cspace$ to be the language accepted by a
regular expression. FTE was originally envisioned to be used with high-entropy
secret keys, and we will extend to allow use with low-entropy keys as well 
in some situations. 

An HE scheme targets $\mdist$ to be some distribution over plaintexts and
$\cdist$ to be uniform over appropriate-length bit strings. An example
from~\cite{juels2014} is an HE scheme for uniformly distributed prime numbers.
This ensures that when encrypting a uniform prime number with a low-entropy
password, an attacker that obtains a ciphertext cannot distinguish between
decrypting ciphertext with the correct password and others. This can prevent
offline-brute force attacks.  To do so, Juels and Ristenpart suggest building HE
schemes  by composing a so-called distribution-transforming encoder (DTE) with
one of several conventional SE encryption algorithm. 
We will also use DTEs, which ``transform'' a value from one distribution to a
value distributed according to another.  A detailed explanation of them appears
in \secref{sec:dte-encrypt-dte}. 


At the simplest level, our main DME constructions will combine the techniques
underlying HE with those underlying FTE and/or stegosystems in a relatively
direct way.  The DME formalization, however, provides a useful framework that
places previous primitives into a unified design space for symmetric encryption.
By seeing gaps in the DME design space not filled by prior primitives, we will
obtain new encryption primitives that fill these gaps.

\tnote{Can we add an example of a scheme that isn't from DTE-Encrypt-DTE? 
Perhaps go with the idea, I think
originally may have been suggested by Yevgeniy, of giving distributions $\mdist$
and/or $\cdist$ for which one provably cannot provide DTEs or, even, DMEs?}






\begin{figure}[t]
\center
\begin{tabular}{|l|c|c|c|l|}
\hline
Primitive & Deterministic & $\mdist$ & $\cdist$ & Security goal\\
\hline
\hline
FTE~\cite{Bellare:2009,ccs12,usenix13} & Sometimes & uniform over set & uniform over set &  AE security\\
HE~\cite{juels2014} & No & arbitrary dist & uniform bit strings & MR, IND\$ \\
Stegonography~\cite{hopper} & No & -- & arbitrary dist & Real-or-dist \\
\hline
PW-based stego & No & arbitrary dist & arbitrary dist & Real-or-dist \\
\hline
\end{tabular}

\tnote{Security field is pretty nebulous. Perhaps recast in terms of the notions 
we present?}
\caption{Primitives captured by the DME formulation, along with the correctness
and security goals sought. The bottom several primitives are novel, falling out
of our DME framework. A dash `--' indicates that no explicit distributions 
are considered.}
\label{fig:primitive-summary}
\end{figure}

