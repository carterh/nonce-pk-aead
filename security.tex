\section{Formal DME Security Notions} 

We give two classes of security targets. In the first class, we consider
security when one has high-entropy keys, i.e., ones drawn uniformly from a
sufficiently large set. Here we can achieve strong security goals akin to that
targeted by Hopper et al.~\cite{hopper} for stegosystems, though we will extend
these goals to provide authenticity properties as well. In the second class, we
consider security when one has low-entropy keys such as passwords. Here we will
explore quite non-standard security goals that, as in HE, take advantage of 
messages being drawn from a known (to the DME scheme designer as well as
attackers) message distribution $\mdist$. 


\paragraph{Real-or-distribution security for high-entropy keys.} We first give a
simple embellishment of the classic security notion for symmetric encryption in
which one asks that an attacker cannot distinguish between encryption under a
key and a random bit string. Instead we ask that no attacker can distinguish
between encryptions and a ciphertext drawn according to $\cdist$. Advantage of
an adversary $\advA$ against a DME scheme $\DMEscheme = (\kg,\enc,\dec)$
relative to a ciphertext distribution $\cdist$ is defined as
\bnm
  \AdvROD{\DMEscheme,\cdist}(\advA) = 
          \left|\Prob{\ROD1_\DMEscheme^\advA\Rightarrow 1}
              - \Prob{\ROD0_{\DMEscheme,\cdist}^\advA\Rightarrow 1}\right| \;.
\enm
ROD security for chosen-plaintext-only attacks
is defined by considering the above but for adversaries that make no decryption
queries. We note that the security as specified will require randomized or
stateful encryption (as we allow repeat queries to the encryption oracle) and
ciphertext stretch (since we require the attacker not to be able to forge
ciphertexts). This means it is unsuitable for FPE or FTE schemes, but one can
give appropriate definitions for such settings should one desire. 


Following a concrete security approach, we will give explicit statements
that measure the resources used by $\advA$ in terms of its worst-case running
time (in some RAM model of computation) and the number of queries $q_e$ to
$\enc$ and $q_d$ to $\dec$. 

It is easy to show ROD this security notion requires high entropy keys, as the
attacker can obtain known plaintext-ciphertext outputs and, therefore, mount
brute-force attacks to recover the key (in the low key entropy case). We also
note that in these settings use of $\mdist$ is, essentially, superflous to
security --- use of this in a scheme will arise next.  \tnote{We need to compare
this notion to the Hopper et al.~one. Intuitively we should be strengthening
their thing, but for the setting of symmetric
encryption.}\tsnote{Similar to [HvAL] notion.  No decryption oracle
there, but the adversary does get to control the ``history'' that
parameterizes encryption/channel sampling.}

\begin{figure}[t]
\center
\hfpages{.20}{
\underline{$\ROD1_{\DMEscheme}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$b' \getsr \advA^{\encOracle,\decOracle}$\\
Ret $b'$\medskip

\underline{proc.~$\encOracle(\msg)$}\\
%If $\msg \in \queriedM$ then Ret $\bot$\\
$\ctxt \getsr \enc(\key,\msg)$ \\
%$\queriedM \gets \queriedM \cup \{\msg\}$\\
$\queriedC \gets \queriedC \cup \{\ctxt\}$\\
Ret $\ctxt$\medskip

\underline{proc.~$\decOracle(\ctxt)$}\\
If $\ctxt \in \queriedC$ then Ret $\bot$\\
$\msg \gets \dec(\key,\ctxt)$\\
Ret $\msg$
}{
\underline{$\ROD0_{\DMEscheme}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$b' \getsr \advA^{\encOracle,\decOracle}$\\
Ret $b'$\medskip

\underline{proc.~$\encOracle(\msg)$}\\
$\ctxt \getc \cspace $\\
Ret $\ctxt$\medskip

\underline{proc.~$\decOracle(\ctxt)$}\\
Ret $\bot$\medskip
}
\caption{Games for real-or-distribution ($\ROD$) security.}
\label{sec:rod-security-games}
\end{figure}

\paragraph{Real-or-distribution security for low-entropy keys.} We now turn to a
variant of the ROD notion for low-entropy keys. As just discussed, in this
setting we cannot give the attacker known plaintext/ciphertext pairs. Rather, we
first turn to a non-interactive setting. 

\begin{figure}[t]
\center
\hfpages{.20}{
\underline{$\leROD1_{\DMEscheme,\kdist,\mdist}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$\msg \getm \mspace$\\
$\ctxt \getsr \enc(\key,\msg)$\\
$b' \getsr \advA(\ctxt)$\\
Ret $b'$
}{
\underline{$\leROD0_{\DMEscheme,\cdist}^\advA$}\\[2pt]
$\ctxt \getc \cspace$\\
$b' \getsr \advA(\ctxt)$\\
Ret $b'$
}

\tnote{Added these games to reflect the attack setting that Tom S is
considering. Could this be a sufficiently interesting target? It doesn't
directly guarantee anything about honey encryption security, but it seems that a
scheme that *isn't* good in the informal HE sense (i.e., ciphertexts are offline
brute-forceable) won't achieve this notion. Can we formalize this a bit more?
Perhaps we were making our lives more complicated than it needed to be in
conversation today...}

\tnote{Games below are a new attempt at something more generally useful}

\hfpages{.20}{
\underline{$\leROD1_{\DMEscheme,\kdist,\mdist}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$\msg \getm \mspace$\\
$\ctxt \getsr \enc(\key,\msg)$\\
For $i = 1$ to $|\kspace|$ do\\
\myind $\msg_i \gets \dec(\key_i,\ctxt)$\\
$b' \getsr \advA(\ctxt,\msg_1,\ldots,\msg_\kappa)$\\
Ret $b'$
}{
\underline{$\leROD0_{\DMEscheme,\cdist}^\advA$}\\[2pt]
$\ctxt \getc \cspace$\\
For $i = 1$ to $|\kspace|$ do\\
\myind $\msg_i \gets \dec(\key_i,\ctxt)$\\
$b' \getsr \advA(\ctxt,\msg_1,\ldots,\msg_\kappa)$\\
Ret $b'$
}

\caption{Games for low-entropy real-or-distribution ($\leROD$) security.}
\label{sec:rod-security-games}
\end{figure}

Advantage of an adversary $\advA$ against a DME scheme $\DMEscheme = (\kg,\enc,\dec)$
relative to a distributions $\kdist$, $\mdist$, and $\cdist$ is 
defined as
\bnm
  \AdvleROD{\DMEscheme,\cdist}(\advA) = 
          \left|\Prob{\leROD1_\DMEscheme^\advA\Rightarrow 1}
              - \Prob{\leROD0_{\DMEscheme,\cdist}^\advA\Rightarrow 1}\right| \;.
\enm


\paragraph{Known-key and low-entropy key indistinguishability.}
Now we turn to the setting where we have low-entropy keys, such as passwords. In
this context we have to deal with the fact that attackers can perform work
sufficient to mount brute-force attacks. This rules out meeting conventional security 
goals such as semantic security, and by implication ROD security. It also rules
out any form of authentication.
\tnote{Do we want to formalize this somewhat obvious claim? Note that Qiang has
been working on stuff related to this.}
The goal is to obtain meaningful security even when using encryption with
low-entropy keys. The approach is to take
advantage of the fact that in many situations a scheme designer knows the 
distribution from which plaintexts will be drawn. We can tailor our schemes to
these distributions, striving to ensure that ciphertexts, even when one can
decrypt with a known key, are indistinguishable from values drawn according
to the target ciphertext distribution $\cdist$. 

We start with the strongest notion, that we call known-key indistinguishability
(KK-IND). The security games are shown in \figref{fig:kkind-games}, and are
parameterized implicitly by a number $q\ge 1$. In the first game $\KKIND1$ the
adversary is given encryptions of~$q$ messages independently drawn according to
$\mdist$ under a single key drawn according to a distribution $\kdist$. In the
second game $\KKIND0$ the adversary is given the decryptions of~$q$ ciphertexts
drawn independently according to $\cdist$ under a key distributed 
as per~$\kdist$.  In the games we have extended our notation so that running
$\enc(\key,\msgvec)$ means running with independent coins
$\enc(\key,\msgvec_1)$, $\enc(\key,\msgvec_2)$, and so on up to
$\enc(\key,\msgvec_q)$. Likewise for $\dec$. 
We define advantage of an adversary $\advA$ against a DME scheme $\DMEscheme$
relative to distributions $\kdist,\mdist,\cdist$ by
\bnm
  \AdvKKIND{\DMEscheme,\kdist,\mdist,\cdist}(\advA) 
    = \left|\Prob{\KKIND1_{\DMEscheme,\kdist,\mdist}^\advA\Rightarrow1} 
          - \Prob{\KKIND0_{\DMEscheme,\kdist,\cdist}^\advA\Rightarrow1} \right| \;.
\enm
When $\advA$ is computationally unbounded, this becomes equivalent to measuring
the statistical distance between the triples $(\key,\msgvec,\ctxtvec)$
as distributed in each game. We say that a scheme $\DMEscheme$ is perfectly 
$(\kdist,\mdist,\cdist)$-$\KKIND$-secure if
$\AdvKKIND{\DMEscheme,\kdist,\mdist,\cdist}(\advA) = 0$ for any $\advA$.

\begin{figure}[t]
\center
\hfpages{.20}{
\underline{$\KKIND1_{\DMEscheme,\kdist,\mdist}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$\msgvec \getm \mspace^q$\\
$\ctxtvec \getsr \enc(\key,\msgvec)$\\
$b' \getsr \advA(\key,\msgvec,\ctxtvec)$\\
Ret $b'$
}{
\underline{$\KKIND0_{\DMEscheme,\kdist,\cdist}^\advA$}\\[2pt]
$\key \getk \kspace$\\
$\ctxtvec \getc \cspace^q$\\
$\msgvec \gets \dec(\key,\ctxtvec)$\\
$b' \getsr \advA(\key,\msgvec,\ctxtvec)$\\
Ret $b'$
}
%\hfpages{.25}{
%\underline{$\textnormal{BLAHH}1_{\DMEscheme}^\advA$}\\[2pt]
%$\key \getk \kspace$\\
%$\msg \getm \mspace$\\
%$\ctxt \getsr \enc(\key,\msg)$\\
%For $i = 1$ to $|\kspace|$ do\\
%\myind $\msg_i \gets \dec(\key_i,\ctxt)$\\
%$b' \getsr \advA(\ctxt,\msg_1,\ldots,\msg_{|\kspace|})$\\
%Ret $b'$\medskip
%}{
%\underline{$\textnormal{BLAHH}0_{\DMEscheme}^\advA$}\\[2pt]
%$\ctxt \getc \cspace$\\
%For $i = 1$ to $|\kspace|$ do\\
%\myind $\msg_i \getm \mspace$\\
%$b' \getsr \advA(\ctxt,\msg_1,\ldots,\msg_{|\kspace|})$\\
%Ret $b'$\medskip
%}
\caption{Games for known-key indistinguishability ($\KKIND$) security.}
\label{fig:kkind-games}
\end{figure}


The $\KKIND$ notion appears strange, and at first glance may seem unachievable. 
After all, we give the adversary the secret key, and one might expect then that
all security goals are lost. But we will in fact show DME schemes can 
achieve this goal, and thereby provide non-cryptographic security properties
that will prove useful in a variety of applications. 

To see how this can be, we exercise the notion with the following positive
result about the simple hash-based DME scheme described in
\secref{sec:basicdefs}. The theorem below shows that the scheme achieves
$\KKIND$ security when considering $\mdist$ and $\cdist$ uniform over $\ell$-bit strings. 


\begin{theorem}
Let $\DMEscheme$ be the hash-based DME scheme from \secref{sec:basicdefs},  
model $H\Colon\bits^*\rightarrow\bits^\ell$ be a function, let $\kdist$ be
arbitrary, and let $\mdist$ and $\cdist$ be uniform over $\bits^\ell$. 
Then $\DMEscheme$ is perfectly $(\kdist,\mdist,\cdist)$-$\KKIND$ secure. 
\end{theorem}

\begin{proof}
The proof holds by the simple observation that xor is a permutation, meaning
that $H(\salt\concat \key) \oplus \msg$ is uniformly distributed when $\msg$ is,
and similarly with $H(\salt\concat\key) \oplus \ctxt$. Thus
$\Pr[(\key,\msgvec,\ctxtvec)] = \Pr[(\key,\msgvec',\ctxtvec')]$ where the
triples represent the event that the indicate values take on a fixed value in
$\KKIND1$ and $\KKIND0$ respectively. \tnote{We should probably come upw ith a
clean way of working directly with the random variables indicated by the games,
since most of our arguments are likely going to reason directly about these
distributions} \qedsym
\end{proof}


\tnote{We need more than $\KKIND$ for steg-PAKE. Well, it may be. Intuitively if
you can modify the behavior of the server by flipping a bit of an encrypted key
exchange value, then this might leak information helpful in speeding-up password
recovery. Have to think this through.}

\tnote{Is there any way to get HE-style security plus authenticity?
Functionality wise one might suspect so: instead of returning~$\bot$... no that
doesn't make sense because it would mean an attacker could force acceptance of a
randomly chosen message from the message distribution.}


\iffalse

\begin{figure}[t]
\center
\hfpages{.48}{
\underline{$\IND1_{\DMEscheme}^\advA$}\\[2pt]
$\key \getsr \kg$\\
$b' \getsr \advA^{\encOracle,\decOracle}$\\
Ret $b'$\medskip

\underline{proc.~$\encOracle(\msg)$}\\
If $\msg \in \queriedM$ then Ret $\bot$\\
$\ctxt \getsr \enc(\key,\msg)$ \tsnote{If $\enc$ is randomized, not
  allow repeated queries?}\\
$\queriedM \gets \queriedM \cup \{\msg\}$\\
$\queriedC \gets \queriedC \cup \{\ctxt\}$\\
Ret $\ctxt$\medskip

\underline{proc.~$\decOracle(\ctxt)$}\\
If $\ctxt \in \queriedC$ then Ret $\bot$\\
$\msg \gets \dec(\key,\ctxt)$\\
$\queriedM \gets \queriedM \cup \{\msg\}$\\
$\queriedC \gets \queriedC \cup \{\ctxt\}$\\
Ret $\msg$
}{
\underline{$\IND0_{\DMEscheme}^\advA$}\\[2pt]
$\key \getsr \kg$\\
$b' \getsr \advA^{\encOracle,\decOracle}$\\
Ret $b'$\medskip

\underline{proc.~$\encOracle(\msg)$}\\
If $\msg \in \queriedM$ then Ret $\bot$\\
$\ctxt \getc \cspace$\\
$\queriedM \gets \queriedM \cup \{\msg\}$\\
$\queriedC \gets \queriedC \cup \{\ctxt\}$\\
Ret $\ctxt$\medskip

\underline{proc.~$\decOracle(\ctxt)$}\\
If $\ctxt \in \queriedC$ then Ret $\bot$\\
$\msg \getm \mspace$\\
$\queriedM \gets \queriedM \cup \{\msg\}$\\
$\queriedC \gets \queriedC \cup \{\ctxt\}$\\
Ret $\msg$
}
\caption{Games used to define security of DME schemes with strong keys.}
\label{fig:mrcca-def}
\end{figure}

\fi





